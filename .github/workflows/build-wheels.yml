name: "Build Wheels and Release"
on:
  workflow_dispatch:
    inputs:
      version:
        description: 'Release version (e.g., 0.17.11)'
        required: true
        type: string
      tag:
        description: 'Git tag (e.g., v0.17.11) - must start with "v"'
        required: true
        type: string
  push:
    branches:
      - master
    tags:
      - 'v*'
env:
  VCPKG_ROOT: ${{ github.workspace }}/vcpkg
  CMAKE_TOOLCHAIN_FILE: ${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake
jobs:
  build-x86_64:
    name: Build x86_64 Wheels (Intel macOS)
    runs-on: macos-15-intel  # Updated from macos-13 (deprecated)
    strategy:
      matrix:
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12', '3.13']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install vcpkg
        run: |
          # Retry logic for network issues
          for i in 1 2 3; do
            if git clone https://github.com/Microsoft/vcpkg.git; then
              break
            fi
            echo "Clone attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          cd vcpkg
          ./bootstrap-vcpkg.sh

      - name: Install nrf-ble-driver (x64-osx)
        run: |
          ./vcpkg/vcpkg install nrf-ble-driver --triplet x64-osx

      - name: Setup standardized build environment
        run: |
          # Use standardized setup script to ensure identical environment
          # This script handles tool versions, environment variables, and fixes
          # Note: Environment variables are set in the build step's env: section
          # This step ensures tools are installed and verified
          bash ./setup_build_environment.sh

      - name: Build x86_64 wheel
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          CMAKE_TOOLCHAIN_FILE: ${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake
          CMAKE_PREFIX_PATH: ${{ github.workspace }}/vcpkg/installed/x64-osx
          MACOSX_DEPLOYMENT_TARGET: 11.0
        run: |
          # Clean _skbuild to ensure fresh build (prevents cross-version contamination)
          rm -rf _skbuild || true
          # Verify we're using the correct Python version
          PYTHON_EXE=$(which python)
          PYTHON_VER=$($PYTHON_EXE -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null)
          EXPECTED_VER="${{ matrix.python-version }}"
          if [ "$PYTHON_VER" != "$EXPECTED_VER" ]; then
            echo "ERROR: Python version mismatch! Expected: $EXPECTED_VER, Got: $PYTHON_VER"
            exit 1
          fi
          echo "✓ Verified Python version: $PYTHON_VER"
          # Get absolute path to Python executable and root directory
          PYTHON_EXE_ABS=$(cd "$(dirname "$PYTHON_EXE")" && pwd)/$(basename "$PYTHON_EXE")
          PYTHON_ROOT_DIR=$(dirname "$(dirname "$PYTHON_EXE_ABS")")
          # CRITICAL: Verify Python library can be found and is correct
          # In GitHub Actions, Python is installed to hostedtoolcache, not a framework
          # This is expected and CMake will find the library using Python3_ROOT_DIR
          PYTHON_LIB=$($PYTHON_EXE_ABS -c "import sysconfig; libdir = sysconfig.get_config_var('LIBDIR'); libfile = sysconfig.get_config_var('LIBRARY'); libpath = f'{libdir}/{libfile}' if libfile else libdir; print(libpath)" 2>/dev/null)
          if [ -n "$PYTHON_LIB" ] && [ -f "$PYTHON_LIB" ]; then
            echo "✓ Found Python library: $PYTHON_LIB"
          else
            echo "ℹ️  Info: Python library not found at expected path: $PYTHON_LIB"
            echo "   This is normal for GitHub Actions Python installations (hostedtoolcache)"
            echo "   CMake will find the correct library using Python3_ROOT_DIR: $PYTHON_ROOT_DIR"
            echo "   Continuing with build..."
          fi
          
          # Build wheel with explicit Python detection flags
          # CRITICAL: Unset PYTHONPATH and adjust PATH to prevent interference
          # CRITICAL: Also ensure we're using the same build environment as local
          echo "=== Build Environment Info ==="
          echo "Python executable: $PYTHON_EXE_ABS"
          echo "Python version: $PYTHON_VER"
          echo "Python library: $PYTHON_LIB"
          echo "Python root: $PYTHON_ROOT_DIR"
          echo ""
          echo "=== System Info ==="
          echo "macOS version: $(sw_vers -productVersion)"
          echo "macOS build: $(sw_vers -buildVersion)"
          echo "Architecture: $(uname -m)"
          echo "Kernel: $(uname -r)"
          echo ""
          echo "=== Compiler Info ==="
          echo "CC: $(which cc)"
          echo "CXX: $(which c++)"
          echo "CC version: $(cc --version 2>/dev/null | head -1 || echo 'Unknown')"
          echo "CXX version: $(c++ --version 2>/dev/null | head -1 || echo 'Unknown')"
          echo ""
          echo "=== Python Build Configuration ==="
          $PYTHON_EXE_ABS -c 'import sysconfig; import sys; macos_target = sysconfig.get_config_var("MACOSX_DEPLOYMENT_TARGET"); cflags = sysconfig.get_config_var("CFLAGS"); ldflags = sysconfig.get_config_var("LDFLAGS"); ldshared = sysconfig.get_config_var("LDSHARED"); cc = sysconfig.get_config_var("CC"); cxx = sysconfig.get_config_var("CXX"); print(f"MACOSX_DEPLOYMENT_TARGET: {macos_target}"); print(f"CFLAGS: {cflags}"); print(f"LDFLAGS: {ldflags}"); print(f"LDSHARED: {ldshared}"); print(f"CC: {cc}"); print(f"CXX: {cxx}"); print(f"Python executable: {sys.executable}"); print(f"Python prefix: {sys.prefix}"); print(f"Python base prefix: {sys.base_prefix}")' 2>&1 || echo "⚠️  Could not get Python build config"
          echo ""
          echo "=== Environment Variables ==="
          echo "VCPKG_ROOT: $VCPKG_ROOT"
          echo "CMAKE_TOOLCHAIN_FILE: $CMAKE_TOOLCHAIN_FILE"
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          echo "DYLD_LIBRARY_PATH: ${DYLD_LIBRARY_PATH:-not set}"
          echo "MACOSX_DEPLOYMENT_TARGET: ${MACOSX_DEPLOYMENT_TARGET:-not set}"
          echo "CFLAGS: ${CFLAGS:-not set}"
          echo "CXXFLAGS: ${CXXFLAGS:-not set}"
          echo "LDFLAGS: ${LDFLAGS:-not set}"
          echo ""
          echo "=== CMake Version ==="
          cmake --version || echo "⚠️  cmake not found"
          echo ""
          echo "=== Building wheel ==="
          BUILD_LOG="/tmp/build_wheel_${PYTHON_VER//./}.log"
          # Capture wheels before build to identify the new one
          WHEELS_BEFORE=$(ls -1 dist/*.whl 2>/dev/null | wc -l || echo "0")
          echo "Wheels in dist/ before build: $WHEELS_BEFORE"
          
          # Patch scikit-build constants.py to handle single-part macOS release (e.g., "15")
          echo "=== Patching scikit-build (x86_64) to handle macOS release format ==="
          $PYTHON_EXE_ABS -c 'import re,sys,traceback; 
import skbuild.constants as c; p=c.__file__; print(f"scikit-build constants.py: {p}"); 
s=open(p,"r").read(); pat=r"major_macos,\s*minor_macos\s*=\s*release\.split\([^)]+\)\[:2\]"; 
import re as _re; 
_m=_re.search(pat,s); 
print("Pattern found" if _m else "Pattern not found"); 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
rep="parts = release.split(\\".\\")\\nif len(parts) < 2:\\n    release = f\\"{parts[0]}.0\\" if parts else \\"15.0\\"\\nmajor_macos, minor_macos = release.split(\\".\\")[:2]"; 
s_new=_re.sub(pat,rep,s) if _m else s; 
(_ := open(p,"w").write(s_new)) if s_new!=s else None; 
print("✓ Patched scikit-build constants.py" if s_new!=s else ("Pattern matched but identical; skipping write" if _m else "Pattern not found in constants.py; no patch applied"))'
          
          # Environment variables are set in the step's env: section above
          # This includes: MACOSX_DEPLOYMENT_TARGET, _SKBUILD_PLAT_NAME, VCPKG_ROOT, etc.
          # _SKBUILD_PLAT_NAME must be set as an env var (not in script) so scikit-build reads it on import
          
          # Use set -o pipefail to ensure we catch errors in the pipeline
          set -o pipefail
          # CRITICAL: Export _SKBUILD_PLAT_NAME so Python/scikit-build can read it
          # This must be exported in the shell environment, not just set as a variable
          export _SKBUILD_PLAT_NAME
          echo "DEBUG: _SKBUILD_PLAT_NAME before build: $_SKBUILD_PLAT_NAME"
          # Verify the variable is set
          if [ -z "$_SKBUILD_PLAT_NAME" ]; then
            echo "ERROR: _SKBUILD_PLAT_NAME is not set!"
            exit 1
          fi
          # CRITICAL: The env command creates a NEW environment
          # We must explicitly pass ALL environment variables we need
          # Including _SKBUILD_PLAT_NAME which scikit-build checks at import time
          if ! env -u PYTHONPATH PATH="$(dirname "$PYTHON_EXE_ABS"):$PATH" \
            MACOSX_DEPLOYMENT_TARGET=$MACOSX_DEPLOYMENT_TARGET \
            _SKBUILD_PLAT_NAME="$_SKBUILD_PLAT_NAME" \
            VCPKG_ROOT="$VCPKG_ROOT" \
            CMAKE_TOOLCHAIN_FILE="$CMAKE_TOOLCHAIN_FILE" \
            CMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH" \
            $PYTHON_EXE_ABS setup.py bdist_wheel --build-type Release -- \
            -DCMAKE_OSX_ARCHITECTURES=x86_64 \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_DEPLOYMENT_TARGET \
            -DPYTHON_EXECUTABLE="$PYTHON_EXE_ABS" \
            -DPython3_EXECUTABLE="$PYTHON_EXE_ABS" \
            -DPython3_ROOT_DIR="$PYTHON_ROOT_DIR" \
            -DPython3_FIND_STRATEGY=LOCATION \
            -DPython3_FIND_REGISTRY=NEVER \
            -DPython3_FIND_VIRTUALENV=ONLY \
            -DCMAKE_FIND_PACKAGE_PREFER_CONFIG=ON \
            2>&1 | tee "$BUILD_LOG"; then
            echo "✗ Build failed - check $BUILD_LOG for details"
            exit 1
          fi
          set +o pipefail
          
          # Verify wheel was created
          echo ""
          echo "=== Verifying wheel was created ==="
          WHEELS_AFTER=$(ls -1 dist/*.whl 2>/dev/null | wc -l || echo "0")
          echo "Wheels in dist/ after build: $WHEELS_AFTER"
          if [ "$WHEELS_AFTER" -le "$WHEELS_BEFORE" ]; then
            echo "✗ ERROR: No new wheel was created!"
            echo "Listing all files in dist/:"
            ls -lah dist/ 2>/dev/null || echo "  dist/ directory does not exist"
            exit 1
          fi
          echo "✓ New wheel created successfully"
          
          # After build, verify the .so file was created and check its linking
          echo ""
          echo "=== Verifying built .so file ==="
          SO_FILE=$(find _skbuild -name "_nrf_ble_driver_sd_api_v5.so" -path "*/x86_64-${PYTHON_VER}/*" 2>/dev/null | head -1)
          if [ -n "$SO_FILE" ] && [ -f "$SO_FILE" ]; then
            echo "Found .so file: $SO_FILE"
            echo "File size: $(ls -lh "$SO_FILE" | awk '{print $5}')"
            echo ""
            echo "=== Linking Info ==="
            otool -L "$SO_FILE" | head -20
            echo ""
            echo "=== Python Library Link ==="
            otool -L "$SO_FILE" | grep -E "(python|Python)" || echo "  ⚠️  No Python library found in linking"
            echo ""
            echo "=== Load Commands ==="
            otool -l "$SO_FILE" | grep -A 5 "LC_LOAD_DYLIB" | head -20
            echo ""
            echo "=== RPath Info ==="
            otool -l "$SO_FILE" | grep -A 2 "LC_RPATH" || echo "  No RPATH found"
            echo ""
            echo "=== File Type ==="
            file "$SO_FILE"
            echo ""
            echo "=== Symbols (first 20) ==="
            nm "$SO_FILE" 2>/dev/null | head -20 || echo "  Could not read symbols"
          else
            echo "⚠️  Warning: Could not find built .so file"
            echo "Searching in _skbuild:"
            find _skbuild -name "*.so" -type f 2>/dev/null | head -10
          fi
          
          # Save build log as artifact for debugging
          echo ""
          echo "=== Build log saved to: $BUILD_LOG ==="
          if [ -f "$BUILD_LOG" ]; then
            echo "Build log size: $(ls -lh "$BUILD_LOG" | awk '{print $5}')"
            echo "Last 50 lines of build log:"
            tail -50 "$BUILD_LOG"
          fi

      - name: Rename wheel to preserve Python version
        if: success()
        run: |
          echo "=== Looking for wheel to rename ==="
          echo "Listing all wheels in dist/:"
          ls -lh dist/*.whl 2>/dev/null || echo "  No wheels found in dist/"
          echo ""
          # Find the wheel that was just built (it will have cp38-abi3 tag internally)
          # With MACOSX_DEPLOYMENT_TARGET=11.0, wheel might be macosx_11_0 or macosx_26_0
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp38-abi3-*x86_64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp38-abi3 pattern, trying broader search..."
            # Try any wheel with cp38 tag (might have different macOS version in name)
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp38-*x86_64*.whl 2>/dev/null | head -1)
          fi
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp38 pattern, trying any cp* pattern..."
            # Fallback: try any wheel with cp tag
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp*-*x86_64*.whl 2>/dev/null | head -1)
          fi
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp* pattern, trying any x86_64 wheel..."
            # Last resort: any x86_64 wheel
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*x86_64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            echo "Found wheel: $(basename "$WHEEL")"
            BASE_NAME=$(basename "$WHEEL")
            # Extract Python version tag (e.g., "3.8" -> "cp38", "3.12" -> "cp312")
            PYTHON_TAG="cp${{ matrix.python-version }}"
            # Remove dots from version for tag (3.10 -> cp310)
            PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
            # Get version from package __init__.py (most reliable)
            VERSION=$(python -c "import sys; sys.path.insert(0, '.'); from pc_ble_driver_py import __version__; print(__version__)" 2>/dev/null)
            if [ -z "$VERSION" ]; then
              # Fallback: extract from wheel filename
              VERSION=$(echo "$BASE_NAME" | sed -n 's/.*pc_ble_driver_py-\([0-9.]*\)-.*/\1/p')
            fi
            if [ -z "$VERSION" ]; then
              echo "Error: Could not determine package version"
              exit 1
            fi
            # Create new name with correct Python tag
            # Extract macOS version from original wheel (might be 11_0 or 26_0)
            MACOS_VERSION=$(echo "$BASE_NAME" | sed -n 's/.*macosx_\([0-9_]*\)_x86_64.*/\1/p')
            if [ -z "$MACOS_VERSION" ]; then
              # Default to 26_0 if we can't extract it
              MACOS_VERSION="26_0"
            fi
            NEW_WHEEL="dist/pc_ble_driver_py-${VERSION}-${PYTHON_TAG}-abi3-macosx_${MACOS_VERSION}_x86_64.whl"
            if [ "$WHEEL" != "$NEW_WHEEL" ]; then
              echo "Renaming wheel to preserve Python version:"
              echo "  From: $(basename $WHEEL)"
              echo "  To:   $(basename $NEW_WHEEL)"
              mv "$WHEEL" "$NEW_WHEEL"
            fi
          else
            echo "Error: No wheel found to rename"
            exit 1
          fi

      - name: Bundle dependencies into wheel
        if: success()
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          VCPKG_TRIPLET: x64-osx
        run: |
          # Find the renamed wheel
          PYTHON_TAG="cp${{ matrix.python-version }}"
          PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-${PYTHON_TAG}-abi3-*x86_64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            # Fallback: try any x86_64 wheel
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*x86_64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            python ${{ github.workspace }}/bundle_into_wheel.py "$WHEEL" || echo "Bundling skipped (optional)"
          fi

      - name: Test wheel after build
        if: success()
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          DYLD_LIBRARY_PATH: ${{ github.workspace }}/vcpkg/installed/x64-osx/lib
        run: |
          # Find the wheel that was just built
          PYTHON_TAG="cp${{ matrix.python-version }}"
          PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-${PYTHON_TAG}-abi3-*x86_64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*x86_64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            echo "Testing wheel: $(basename $WHEEL)"
            # Get absolute path to wheel
            WHEEL_ABS=$(cd "$(dirname "$WHEEL")" && pwd)/$(basename "$WHEEL")
            # Extract wheel manually (it's just a zip file) to bypass pip's platform check
            TEMP_INSTALL_DIR=$(mktemp -d)
            cd "$TEMP_INSTALL_DIR"
            unzip -q "$WHEEL_ABS" 2>/dev/null || {
              echo "✗ Failed to extract wheel"
              rm -rf "$TEMP_INSTALL_DIR"
              exit 1
            }
            # Wheels extract with package directories at the root
            # PYTHONPATH should point to the directory containing pc_ble_driver_py
            # The extracted wheel has pc_ble_driver_py/ at the root of TEMP_INSTALL_DIR
            export PYTHONPATH="$TEMP_INSTALL_DIR:$PYTHONPATH"
            cd - > /dev/null
            # Test imports with DYLD_LIBRARY_PATH set
            # Use timeout to catch segfaults (exit code 139)
            if command -v timeout >/dev/null 2>&1; then
              TIMEOUT_CMD="timeout 30"
            else
              TIMEOUT_CMD=""
            fi
            $TIMEOUT_CMD python -c 'import sys; import os; TEMP_DIR = os.environ.get("PYTHONPATH", "").split(":")[0] if os.environ.get("PYTHONPATH") else ""; [sys.path.insert(0, TEMP_DIR) for _ in [None] if TEMP_DIR]; sys.path = [p for p in sys.path if p and (TEMP_DIR in p or "site-packages" in p or "lib/python" in p or "Frameworks/Python.framework" in p)]; import pc_ble_driver_py; print("✓ Imported pc_ble_driver_py"); import pc_ble_driver_py.lib.nrf_ble_driver_sd_api_v5; print("✓ Imported nrf_ble_driver_sd_api_v5"); from pc_ble_driver_py.ble_driver import BLEDriver; print("✓ Imported BLEDriver"); driver = BLEDriver(); print("✓ Created BLEDriver instance"); print("✓ Wheel test passed")' 2>&1
            TEST_EXIT=$?
            # Clean up temp install directory
            rm -rf "$TEMP_INSTALL_DIR" 2>/dev/null || true
            if [ $TEST_EXIT -eq 0 ]; then
              echo "✓ Wheel test passed"
            elif [ $TEST_EXIT -eq 139 ]; then
              echo "✗ Wheel test FAILED - SEGFAULT (exit code: 139)"
              echo "  This wheel will not be uploaded"
              exit 1
            else
              echo "✗ Wheel test FAILED (exit code: $TEST_EXIT)"
              echo "  This wheel will not be uploaded"
              exit 1
            fi
          else
            echo "⚠️  No wheel found to test"
          fi

      - name: Upload build logs (x86_64)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-x86_64-py${{ matrix.python-version }}
          path: /tmp/build_wheel_*.log
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload x86_64 wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-x86_64-py${{ matrix.python-version }}
          path: dist/*x86_64*.whl
          if-no-files-found: warn

  build-arm64:
    name: Build ARM64 Wheels (Apple Silicon)
    runs-on: macos-latest  # macOS 15 ARM64 (Apple Silicon)
    strategy:
      matrix:
        python-version: ['3.8', '3.9', '3.10', '3.11', '3.12', '3.13']
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}

      - name: Install vcpkg
        run: |
          # Retry logic for network issues
          for i in 1 2 3; do
            if git clone https://github.com/Microsoft/vcpkg.git; then
              break
            fi
            echo "Clone attempt $i failed, retrying in 5 seconds..."
            sleep 5
          done
          cd vcpkg
          ./bootstrap-vcpkg.sh

      - name: Install nrf-ble-driver (arm64-osx)
        run: |
          ./vcpkg/vcpkg install nrf-ble-driver --triplet arm64-osx

      - name: Setup standardized build environment
        run: |
          # Use standardized setup script to ensure identical environment
          # This script handles tool versions, environment variables, and fixes
          # Note: Environment variables are set in the build step's env: section
          # This step ensures tools are installed and verified
          bash ./setup_build_environment.sh

      - name: Build ARM64 wheel
        env:
          # Environment variables are set by setup_build_environment.sh
          # These are kept here for explicit documentation
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          CMAKE_TOOLCHAIN_FILE: ${{ github.workspace }}/vcpkg/scripts/buildsystems/vcpkg.cmake
          CMAKE_PREFIX_PATH: ${{ github.workspace }}/vcpkg/installed/arm64-osx
          MACOSX_DEPLOYMENT_TARGET: 11.0
          # CRITICAL: Set _SKBUILD_PLAT_NAME before Python imports scikit-build
          # This must be set as an environment variable, not in the script
          # GitHub Actions uses macOS 15.7, so we use macosx-15.7-arm64
          _SKBUILD_PLAT_NAME: macosx-15.7-arm64
        run: |
          # Clean _skbuild to ensure fresh build (prevents cross-version contamination)
          rm -rf _skbuild || true
          # Verify we're using the correct Python version
          PYTHON_EXE=$(which python)
          PYTHON_VER=$($PYTHON_EXE -c "import sys; print(f'{sys.version_info.major}.{sys.version_info.minor}')" 2>/dev/null)
          EXPECTED_VER="${{ matrix.python-version }}"
          if [ "$PYTHON_VER" != "$EXPECTED_VER" ]; then
            echo "ERROR: Python version mismatch! Expected: $EXPECTED_VER, Got: $PYTHON_VER"
            exit 1
          fi
          echo "✓ Verified Python version: $PYTHON_VER"
          # Get absolute path to Python executable and root directory
          PYTHON_EXE_ABS=$(cd "$(dirname "$PYTHON_EXE")" && pwd)/$(basename "$PYTHON_EXE")
          PYTHON_ROOT_DIR=$(dirname "$(dirname "$PYTHON_EXE_ABS")")
          
          # CRITICAL: Verify Python library can be found and is correct
          # In GitHub Actions, Python is installed to hostedtoolcache, not a framework
          # This is expected and CMake will find the library using Python3_ROOT_DIR
          PYTHON_LIB=$($PYTHON_EXE_ABS -c "import sysconfig; libdir = sysconfig.get_config_var('LIBDIR'); libfile = sysconfig.get_config_var('LIBRARY'); libpath = f'{libdir}/{libfile}' if libfile else libdir; print(libpath)" 2>/dev/null)
          if [ -n "$PYTHON_LIB" ] && [ -f "$PYTHON_LIB" ]; then
            echo "✓ Found Python library: $PYTHON_LIB"
          else
            echo "ℹ️  Info: Python library not found at expected path: $PYTHON_LIB"
            echo "   This is normal for GitHub Actions Python installations (hostedtoolcache)"
            echo "   CMake will find the correct library using Python3_ROOT_DIR: $PYTHON_ROOT_DIR"
            echo "   Continuing with build..."
          fi
          
          # Build wheel with explicit Python detection flags
          # CRITICAL: Unset PYTHONPATH and adjust PATH to prevent interference
          # CRITICAL: Also ensure we're using the same build environment as local
          echo "=== Build Environment Info ==="
          echo "Python executable: $PYTHON_EXE_ABS"
          echo "Python version: $PYTHON_VER"
          echo "Python library: $PYTHON_LIB"
          echo "Python root: $PYTHON_ROOT_DIR"
          echo ""
          echo "=== System Info ==="
          echo "macOS version: $(sw_vers -productVersion)"
          echo "macOS build: $(sw_vers -buildVersion)"
          echo "Architecture: $(uname -m)"
          echo "Kernel: $(uname -r)"
          echo ""
          echo "=== Compiler Info ==="
          echo "CC: $(which cc)"
          echo "CXX: $(which c++)"
          echo "CC version: $(cc --version 2>/dev/null | head -1 || echo 'Unknown')"
          echo "CXX version: $(c++ --version 2>/dev/null | head -1 || echo 'Unknown')"
          echo ""
          echo "=== Python Build Configuration ==="
          $PYTHON_EXE_ABS -c 'import sysconfig; import sys; macos_target = sysconfig.get_config_var("MACOSX_DEPLOYMENT_TARGET"); cflags = sysconfig.get_config_var("CFLAGS"); ldflags = sysconfig.get_config_var("LDFLAGS"); ldshared = sysconfig.get_config_var("LDSHARED"); cc = sysconfig.get_config_var("CC"); cxx = sysconfig.get_config_var("CXX"); print(f"MACOSX_DEPLOYMENT_TARGET: {macos_target}"); print(f"CFLAGS: {cflags}"); print(f"LDFLAGS: {ldflags}"); print(f"LDSHARED: {ldshared}"); print(f"CC: {cc}"); print(f"CXX: {cxx}"); print(f"Python executable: {sys.executable}"); print(f"Python prefix: {sys.prefix}"); print(f"Python base prefix: {sys.base_prefix}")' 2>&1 || echo "⚠️  Could not get Python build config"
          echo ""
          echo "=== Environment Variables ==="
          echo "VCPKG_ROOT: $VCPKG_ROOT"
          echo "CMAKE_TOOLCHAIN_FILE: $CMAKE_TOOLCHAIN_FILE"
          echo "CMAKE_PREFIX_PATH: $CMAKE_PREFIX_PATH"
          echo "DYLD_LIBRARY_PATH: ${DYLD_LIBRARY_PATH:-not set}"
          echo "MACOSX_DEPLOYMENT_TARGET: ${MACOSX_DEPLOYMENT_TARGET:-not set}"
          echo "CFLAGS: ${CFLAGS:-not set}"
          echo "CXXFLAGS: ${CXXFLAGS:-not set}"
          echo "LDFLAGS: ${LDFLAGS:-not set}"
          echo ""
          echo "=== CMake Version ==="
          cmake --version || echo "⚠️  cmake not found"
          echo ""
          echo "=== Building wheel ==="
          BUILD_LOG="/tmp/build_wheel_${PYTHON_VER//./}.log"
          # Capture wheels before build to identify the new one
          WHEELS_BEFORE=$(ls -1 dist/*.whl 2>/dev/null | wc -l || echo "0")
          echo "Wheels in dist/ before build: $WHEELS_BEFORE"
          
          # Patch scikit-build constants.py to handle single-part macOS release (e.g., "15")
          echo "=== Patching scikit-build (ARM64) to handle macOS release format ==="
          $PYTHON_EXE_ABS -c 'import re,sys,traceback; import skbuild.constants as c; p=c.__file__; print(f"scikit-build constants.py: {p}"); s=open(p,"r").read(); pat=r"major_macos,\s*minor_macos\s*=\s*release\.split\([^)]+\)\[:2\]"; _m=re.search(pat,s); rep="parts = release.split(\\".\\")\\nif len(parts) < 2:\\n    release = f\\"{parts[0]}.0\\" if parts else \\"15.0\\"\\nmajor_macos, minor_macos = release.split(\\".\\")[:2]"; s_new=re.sub(pat,rep,s) if _m else s; (_ := open(p,\\"w\\").write(s_new)) if s_new!=s else None; print(\\"✓ Patched scikit-build constants.py\\" if s_new!=s else (\\"Pattern matched but identical; skipping write\\" if _m else \\"Pattern not found in constants.py; no patch applied\\"))'
          
          # Environment variables are set in the step's env: section above
          # This includes: MACOSX_DEPLOYMENT_TARGET, _SKBUILD_PLAT_NAME, VCPKG_ROOT, etc.
          # _SKBUILD_PLAT_NAME must be set as an env var (not in script) so scikit-build reads it on import
          
          # Use set -o pipefail to ensure we catch errors in the pipeline
          set -o pipefail
          # CRITICAL: Export _SKBUILD_PLAT_NAME so Python/scikit-build can read it
          # This must be exported in the shell environment, not just set as a variable
          export _SKBUILD_PLAT_NAME
          echo "DEBUG: _SKBUILD_PLAT_NAME before build: $_SKBUILD_PLAT_NAME"
          # Verify the variable is set
          if [ -z "$_SKBUILD_PLAT_NAME" ]; then
            echo "ERROR: _SKBUILD_PLAT_NAME is not set!"
            exit 1
          fi
          # CRITICAL: The env command creates a NEW environment
          # We must explicitly pass ALL environment variables we need
          # Including _SKBUILD_PLAT_NAME which scikit-build checks at import time
          if ! env -u PYTHONPATH PATH="$(dirname "$PYTHON_EXE_ABS"):$PATH" \
            MACOSX_DEPLOYMENT_TARGET=$MACOSX_DEPLOYMENT_TARGET \
            _SKBUILD_PLAT_NAME="$_SKBUILD_PLAT_NAME" \
            VCPKG_ROOT="$VCPKG_ROOT" \
            CMAKE_TOOLCHAIN_FILE="$CMAKE_TOOLCHAIN_FILE" \
            CMAKE_PREFIX_PATH="$CMAKE_PREFIX_PATH" \
            $PYTHON_EXE_ABS setup.py bdist_wheel --build-type Release -- \
            -DCMAKE_OSX_ARCHITECTURES=arm64 \
            -DCMAKE_OSX_DEPLOYMENT_TARGET=$MACOSX_DEPLOYMENT_TARGET \
            -DPYTHON_EXECUTABLE="$PYTHON_EXE_ABS" \
            -DPython3_EXECUTABLE="$PYTHON_EXE_ABS" \
            -DPython3_ROOT_DIR="$PYTHON_ROOT_DIR" \
            -DPython3_FIND_STRATEGY=LOCATION \
            -DPython3_FIND_REGISTRY=NEVER \
            -DPython3_FIND_VIRTUALENV=ONLY \
            -DCMAKE_FIND_PACKAGE_PREFER_CONFIG=ON \
            2>&1 | tee "$BUILD_LOG"; then
            echo "✗ Build failed - check $BUILD_LOG for details"
            exit 1
          fi
          set +o pipefail
          
          # Verify wheel was created
          echo ""
          echo "=== Verifying wheel was created ==="
          WHEELS_AFTER=$(ls -1 dist/*.whl 2>/dev/null | wc -l || echo "0")
          echo "Wheels in dist/ after build: $WHEELS_AFTER"
          if [ "$WHEELS_AFTER" -le "$WHEELS_BEFORE" ]; then
            echo "✗ ERROR: No new wheel was created!"
            echo "Listing all files in dist/:"
            ls -lah dist/ 2>/dev/null || echo "  dist/ directory does not exist"
            exit 1
          fi
          echo "✓ New wheel created successfully"
          
          # After build, verify the .so file was created and check its linking
          echo ""
          echo "=== Verifying built .so file ==="
          SO_FILE=$(find _skbuild -name "_nrf_ble_driver_sd_api_v5.so" -path "*/arm64-${PYTHON_VER}/*" 2>/dev/null | head -1)
          if [ -n "$SO_FILE" ] && [ -f "$SO_FILE" ]; then
            echo "Found .so file: $SO_FILE"
            echo "File size: $(ls -lh "$SO_FILE" | awk '{print $5}')"
            echo ""
            echo "=== Linking Info ==="
            otool -L "$SO_FILE" | head -20
            echo ""
            echo "=== Python Library Link ==="
            otool -L "$SO_FILE" | grep -E "(python|Python)" || echo "  ⚠️  No Python library found in linking"
            echo ""
            echo "=== Load Commands ==="
            otool -l "$SO_FILE" | grep -A 5 "LC_LOAD_DYLIB" | head -20
            echo ""
            echo "=== RPath Info ==="
            otool -l "$SO_FILE" | grep -A 2 "LC_RPATH" || echo "  No RPATH found"
            echo ""
            echo "=== File Type ==="
            file "$SO_FILE"
            echo ""
            echo "=== Symbols (first 20) ==="
            nm "$SO_FILE" 2>/dev/null | head -20 || echo "  Could not read symbols"
          else
            echo "⚠️  Warning: Could not find built .so file"
            echo "Searching in _skbuild:"
            find _skbuild -name "*.so" -type f 2>/dev/null | head -10
          fi
          
          # Save build log as artifact for debugging
          echo ""
          echo "=== Build log saved to: $BUILD_LOG ==="
          if [ -f "$BUILD_LOG" ]; then
            echo "Build log size: $(ls -lh "$BUILD_LOG" | awk '{print $5}')"
            echo "Last 50 lines of build log:"
            tail -50 "$BUILD_LOG"
          fi

      - name: Rename wheel to preserve Python version
        if: success()
        run: |
          echo "=== Looking for wheel to rename ==="
          echo "Python version: ${{ matrix.python-version }}"
          echo "Current directory: $(pwd)"
          echo ""
          echo "Listing all files in dist/:"
          ls -lah dist/ 2>/dev/null || echo "  dist/ directory does not exist"
          echo ""
          echo "Listing all wheels in dist/:"
          ls -lh dist/*.whl 2>/dev/null || echo "  No wheels found in dist/"
          echo ""
          # Find the wheel that was just built (it will have cp38-abi3 tag internally)
          # With MACOSX_DEPLOYMENT_TARGET=11.0, wheel might be macosx_11_0 or macosx_26_0
          # scikit-build always tags wheels as cp38-abi3 internally, regardless of Python version
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp38-abi3-*arm64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp38-abi3 pattern, trying broader search..."
            # Try any wheel with cp38 tag (might have different macOS version in name)
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp38-*arm64*.whl 2>/dev/null | head -1)
          fi
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp38 pattern, trying any cp* pattern..."
            # Fallback: try any wheel with cp tag
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-cp*-*arm64*.whl 2>/dev/null | head -1)
          fi
          if [ -z "$WHEEL" ]; then
            echo "No wheel found with cp* pattern, trying any arm64 wheel..."
            # Last resort: any arm64 wheel
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*arm64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            echo "Found wheel: $(basename "$WHEEL")"
            BASE_NAME=$(basename "$WHEEL")
            # Extract Python version tag (e.g., "3.8" -> "cp38", "3.12" -> "cp312")
            PYTHON_TAG="cp${{ matrix.python-version }}"
            # Remove dots from version for tag (3.10 -> cp310)
            PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
            # Get version from package __init__.py (most reliable)
            VERSION=$(python -c "import sys; sys.path.insert(0, '.'); from pc_ble_driver_py import __version__; print(__version__)" 2>/dev/null)
            if [ -z "$VERSION" ]; then
              # Fallback: extract from wheel filename
              VERSION=$(echo "$BASE_NAME" | sed -n 's/.*pc_ble_driver_py-\([0-9.]*\)-.*/\1/p')
            fi
            if [ -z "$VERSION" ]; then
              echo "Error: Could not determine package version"
              exit 1
            fi
            # Create new name with correct Python tag
            NEW_WHEEL="dist/pc_ble_driver_py-${VERSION}-${PYTHON_TAG}-abi3-macosx_26_0_arm64.whl"
            if [ "$WHEEL" != "$NEW_WHEEL" ]; then
              echo "Renaming wheel to preserve Python version:"
              echo "  From: $(basename $WHEEL)"
              echo "  To:   $(basename $NEW_WHEEL)"
              mv "$WHEEL" "$NEW_WHEEL"
            fi
          else
            echo "Error: No wheel found to rename"
            exit 1
          fi

      - name: Bundle dependencies into wheel
        if: success()
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          VCPKG_TRIPLET: arm64-osx
        run: |
          # Find the renamed wheel
          PYTHON_TAG="cp${{ matrix.python-version }}"
          PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-${PYTHON_TAG}-abi3-*arm64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            # Fallback: try any arm64 wheel
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*arm64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            python ${{ github.workspace }}/bundle_into_wheel.py "$WHEEL" || echo "Bundling skipped (optional)"
          fi

      - name: Test wheel after build
        if: success()
        env:
          VCPKG_ROOT: ${{ github.workspace }}/vcpkg
          DYLD_LIBRARY_PATH: ${{ github.workspace }}/vcpkg/installed/arm64-osx/lib
        run: |
          # Find the wheel that was just built
          PYTHON_TAG="cp${{ matrix.python-version }}"
          PYTHON_TAG=$(echo "$PYTHON_TAG" | sed 's/\.//g')
          WHEEL=$(ls -t dist/pc_ble_driver_py-*-${PYTHON_TAG}-abi3-*arm64*.whl 2>/dev/null | head -1)
          if [ -z "$WHEEL" ]; then
            WHEEL=$(ls -t dist/pc_ble_driver_py-*-*arm64*.whl 2>/dev/null | head -1)
          fi
          if [ -n "$WHEEL" ] && [ -f "$WHEEL" ]; then
            echo "Testing wheel: $(basename $WHEEL)"
            # Get absolute path to wheel
            WHEEL_ABS=$(cd "$(dirname "$WHEEL")" && pwd)/$(basename "$WHEEL")
            # Extract wheel manually (it's just a zip file) to bypass pip's platform check
            TEMP_INSTALL_DIR=$(mktemp -d)
            cd "$TEMP_INSTALL_DIR"
            unzip -q "$WHEEL_ABS" 2>/dev/null || {
              echo "✗ Failed to extract wheel"
              rm -rf "$TEMP_INSTALL_DIR"
              exit 1
            }
            # Wheels extract with package directories at the root
            # PYTHONPATH should point to the directory containing pc_ble_driver_py
            # The extracted wheel has pc_ble_driver_py/ at the root of TEMP_INSTALL_DIR
            export PYTHONPATH="$TEMP_INSTALL_DIR:$PYTHONPATH"
            cd - > /dev/null
            # Test imports with DYLD_LIBRARY_PATH set
            # Use timeout to catch segfaults (exit code 139)
            if command -v timeout >/dev/null 2>&1; then
              TIMEOUT_CMD="timeout 30"
            else
              TIMEOUT_CMD=""
            fi
            $TIMEOUT_CMD python -c 'import sys; import os; TEMP_DIR = os.environ.get("PYTHONPATH", "").split(":")[0] if os.environ.get("PYTHONPATH") else ""; [sys.path.insert(0, TEMP_DIR) for _ in [None] if TEMP_DIR]; sys.path = [p for p in sys.path if p and (TEMP_DIR in p or "site-packages" in p or "lib/python" in p or "Frameworks/Python.framework" in p)]; import pc_ble_driver_py; print("✓ Imported pc_ble_driver_py"); import pc_ble_driver_py.lib.nrf_ble_driver_sd_api_v5; print("✓ Imported nrf_ble_driver_sd_api_v5"); from pc_ble_driver_py.ble_driver import BLEDriver; print("✓ Imported BLEDriver"); driver = BLEDriver(); print("✓ Created BLEDriver instance"); print("✓ Wheel test passed")' 2>&1
            TEST_EXIT=$?
            # Clean up temp install directory
            rm -rf "$TEMP_INSTALL_DIR" 2>/dev/null || true
            if [ $TEST_EXIT -eq 0 ]; then
              echo "✓ Wheel test passed"
            elif [ $TEST_EXIT -eq 139 ]; then
              echo "✗ Wheel test FAILED - SEGFAULT (exit code: 139)"
              echo "  This wheel will not be uploaded"
              exit 1
            else
              echo "✗ Wheel test FAILED (exit code: $TEST_EXIT)"
              echo "  This wheel will not be uploaded"
              exit 1
            fi
          else
            echo "⚠️  No wheel found to test"
          fi

      - name: Upload build logs (ARM64)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-arm64-py${{ matrix.python-version }}
          path: /tmp/build_wheel_*.log
          if-no-files-found: ignore
          retention-days: 7

      - name: Upload ARM64 wheel
        uses: actions/upload-artifact@v4
        with:
          name: wheel-arm64-py${{ matrix.python-version }}
          path: dist/*arm64*.whl
          if-no-files-found: warn

  create-release:
    name: Create Release
    needs: [build-x86_64, build-arm64]
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.tag != ''
    permissions:
      contents: write  # Required to create/delete releases
    steps:
      - name: Validate tag format
        run: |
          TAG="${{ github.event.inputs.tag }}"
          if [[ ! "$TAG" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "ERROR: Tag must be in format 'vX.Y.Z' (e.g., v0.17.11)"
            echo "Received: $TAG"
            exit 1
          fi
          echo "✓ Tag format valid: $TAG"
      
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: master
          fetch-depth: 0
          fetch-tags: true

      - name: Download x86_64 wheels
        uses: actions/download-artifact@v4
        with:
          path: wheels/x86_64
          pattern: wheel-x86_64-*
          merge-multiple: true

      - name: Download ARM64 wheels
        uses: actions/download-artifact@v4
        with:
          path: wheels/arm64
          pattern: wheel-arm64-*
          merge-multiple: true

      - name: List downloaded wheels
        run: |
          echo "=== x86_64 wheels ==="
          ls -lh wheels/x86_64/*.whl 2>/dev/null | awk '{print $9, "(" $5 ")"}' || echo "No x86_64 wheels found"
          echo ""
          echo "=== ARM64 wheels ==="
          ls -lh wheels/arm64/*.whl 2>/dev/null | awk '{print $9, "(" $5 ")"}' || echo "No ARM64 wheels found"
          echo ""
          echo "=== Expected: 6 x86_64 wheels (cp38, cp39, cp310, cp311, cp312, cp313) ==="
          echo "=== Expected: 6 ARM64 wheels (cp38, cp39, cp310, cp311, cp312, cp313) ==="
          X86_COUNT=$(ls -1 wheels/x86_64/*.whl 2>/dev/null | wc -l | tr -d ' ')
          ARM64_COUNT=$(ls -1 wheels/arm64/*.whl 2>/dev/null | wc -l | tr -d ' ')
          echo "Found: $X86_COUNT x86_64 wheels, $ARM64_COUNT ARM64 wheels"
          if [ "$X86_COUNT" -lt 6 ] || [ "$ARM64_COUNT" -lt 6 ]; then
            echo "WARNING: Expected 12 wheels total, but found $((X86_COUNT + ARM64_COUNT))"
            echo "This may indicate that some builds failed or wheels were not renamed correctly"
          fi

      - name: Delete existing release (if any)
        run: |
          gh release delete "${{ github.event.inputs.tag }}" --yes 2>/dev/null || echo "No existing release to delete"
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        continue-on-error: true

      - name: Create release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.event.inputs.tag }}
          name: Release ${{ github.event.inputs.version }}
          body: |
            Release ${{ github.event.inputs.version }}
            
            ## Wheels Included
            
            ### x86_64 (Intel Mac)
            - Python 3.8, 3.9, 3.10, 3.11, 3.12, 3.13
            
            ### ARM64 (Apple Silicon)
            - Python 3.8, 3.9, 3.10, 3.11, 3.12, 3.13
            
            ## Installation
            
            ```bash
            # For x86_64 (Intel Mac)
            pip install https://github.com/kimalive/pc-ble-driver-py/releases/download/${{ github.event.inputs.tag }}/pc_ble_driver_py-${{ github.event.inputs.version }}-cp312-abi3-macosx_26_0_x86_64.whl
            
            # For ARM64 (Apple Silicon)
            pip install https://github.com/kimalive/pc-ble-driver-py/releases/download/${{ github.event.inputs.tag }}/pc_ble_driver_py-${{ github.event.inputs.version }}-cp312-abi3-macosx_26_0_arm64.whl
            ```
            
            Replace `cp312` with your Python version (cp38, cp39, cp310, cp311, cp312, cp313).
          files: |
            wheels/x86_64/*.whl
            wheels/arm64/*.whl
          fail_on_unmatched_files: true
          draft: false
          prerelease: false
          make_latest: true
